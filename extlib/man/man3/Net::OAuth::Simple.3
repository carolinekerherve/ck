.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::OAuth::Simple 3"
.TH Net::OAuth::Simple 3 "2010-08-04" "perl v5.19.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::OAuth::Simple \- a simple wrapper round the OAuth protocol
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
First create a sub class of \f(CW\*(C`Net::OAuth::Simple\*(C'\fR that will do you requests
for you.
.PP
.Vb 1
\&    package Net::AppThatUsesOAuth;
\&
\&    use strict;
\&    use base qw(Net::OAuth::Simple);
\&
\&
\&    sub new {
\&        my $class  = shift;
\&        my %tokens = @_;
\&        return $class\->SUPER::new( tokens => \e%tokens, 
\&                                   protocol_version => \*(Aq1.0a\*(Aq,
\&                                   urls   => {
\&                                        authorization_url => ...,
\&                                        request_token_url => ...,
\&                                        access_token_url  => ...,
\&                                   });
\&    }
\&
\&    sub view_restricted_resource {
\&        my $self = shift;
\&        my $url  = shift;
\&        return $self\->make_restricted_request($url, \*(AqGET\*(Aq);
\&    }
\&
\&    sub update_restricted_resource {
\&        my $self         = shift;
\&        my $url          = shift;
\&        my %extra_params = @_;
\&        return $self\->make_restricted_request($url, \*(AqPOST\*(Aq, %extra_params);    
\&    }
\&    1;
.Ve
.PP
Then in your main app you need to do
.PP
.Vb 3
\&    # Get the tokens from the command line, a config file or wherever 
\&    my %tokens  = get_tokens(); 
\&    my $app     = Net::AppThatUsesOAuth\->new(%tokens);
\&
\&    # Check to see we have a consumer key and secret
\&    unless ($app\->consumer_key && $app\->consumer_secret) {
\&        die "You must go get a consumer key and secret from App\en";
\&    } 
\&    
\&    # If the app is authorized (i.e has an access token and secret)
\&    # Then look at a restricted resourse
\&    if ($app\->authorized) {
\&        my $response = $app\->view_restricted_resource;
\&        print $response\->content."\en";
\&        exit;
\&    }
\&
\&
\&    # Otherwise the user needs to go get an access token and secret
\&    print "Go to ".$app\->get_authorization_url."\en";
\&    print "Then hit return after\en";
\&    <STDIN>;
\&
\&    my ($access_token, $access_token_secret) = $app\->request_access_token;
\&
\&    # Now save those values
.Ve
.PP
Note the flow will be somewhat different for web apps since the request token 
and secret will need to be saved whilst the user visits the authorization url.
.PP
For examples go look at the \f(CW\*(C`Net::FireEagle\*(C'\fR module and the \f(CW\*(C`fireeagle\*(C'\fR command 
line script that ships with it. Also in the same distribution in the \f(CW\*(C`examples/\*(C'\fR
directory is a sample web app.
.SH "METHODS"
.IX Header "METHODS"
.SS "new [params]"
.IX Subsection "new [params]"
Create a new OAuth enabled app \- takes a hash of params.
.PP
One of the keys of the hash must be \f(CW\*(C`tokens\*(C'\fR, the value of which
must be a hash ref with the keys:
.IP "consumer_key" 4
.IX Item "consumer_key"
.PD 0
.IP "consumer_secret" 4
.IX Item "consumer_secret"
.PD
.PP
Then, when you have your per-use access token and secret you 
can supply
.IP "access_token" 4
.IX Item "access_token"
.PD 0
.IP "access_secret" 4
.IX Item "access_secret"
.PD
.PP
Another key of the hash must be \f(CW\*(C`urls\*(C'\fR, the value of which must 
be a hash ref with the keys
.IP "authorization_url" 4
.IX Item "authorization_url"
.PD 0
.IP "request_token_url" 4
.IX Item "request_token_url"
.IP "access_token_url" 4
.IX Item "access_token_url"
.PD
.PP
If you pass in a key \f(CW\*(C`protocol_version\*(C'\fR with a value equal to \fB1.0a\fR then 
the newest version of the OAuth protocol will be used. A value equal to \fB1.0\fR will 
mean the old version will be used. Defaults to \fB1.0a\fR
.PP
You can pass in your own User Agent by using the key \f(CW\*(C`browser\*(C'\fR.
.PP
If you pass in \f(CW\*(C`return_undef_on_error\*(C'\fR then instead of \f(CW\*(C`die\*(C'\fR\-ing on error  
methods will return undef instead and the error can be retrieved using the 
\&\f(CW\*(C`last_error()\*(C'\fR method. See the section on \fB\s-1ERROR HANDLING\s0\fR.
.SS "oauth_1_0a"
.IX Subsection "oauth_1_0a"
Whether or not we're using 1.0a version of OAuth (necessary for, 
amongst others, FireEagle)
.SS "authorized"
.IX Subsection "authorized"
Whether the client has the necessary credentials to be authorized.
.PP
Note that the credentials may be wrong and so the request may still fail.
.SS "signature_method [method]"
.IX Subsection "signature_method [method]"
The signature method to use.
.PP
Defaults to \s-1HMAC\-SHA1\s0
.SS "tokens"
.IX Subsection "tokens"
Get all the tokens.
.SS "consumer_key [consumer key]"
.IX Subsection "consumer_key [consumer key]"
Returns the current consumer key.
.PP
Can optionally set the consumer key.
.SS "consumer_secret [consumer secret]"
.IX Subsection "consumer_secret [consumer secret]"
Returns the current consumer secret.
.PP
Can optionally set the consumer secret.
.SS "access_token [access_token]"
.IX Subsection "access_token [access_token]"
Returns the current access token.
.PP
Can optionally set a new token.
.SS "access_token_secret [access_token_secret]"
.IX Subsection "access_token_secret [access_token_secret]"
Returns the current access token secret.
.PP
Can optionally set a new secret.
.SS "general_token [token]"
.IX Subsection "general_token [token]"
Get or set the general token.
.PP
See documentation in \f(CW\*(C`new()\*(C'\fR
.SS "general_token_secret [secret]"
.IX Subsection "general_token_secret [secret]"
Get or set the general token secret.
.PP
See documentation in \f(CW\*(C`new()\*(C'\fR
.SS "authorized_general_token"
.IX Subsection "authorized_general_token"
Is the app currently authorized for general token requests.
.PP
See documentation in \f(CW\*(C`new()\*(C'\fR
.SS "request_token [request_token]"
.IX Subsection "request_token [request_token]"
Returns the current request token.
.PP
Can optionally set a new token.
.SS "request_token_secret [request_token_secret]"
.IX Subsection "request_token_secret [request_token_secret]"
Returns the current request token secret.
.PP
Can optionally set a new secret.
.SS "verifier [verifier]"
.IX Subsection "verifier [verifier]"
Returns the current oauth_verifier.
.PP
Can optionally set a new verifier.
.SS "callback [callback]"
.IX Subsection "callback [callback]"
Returns the oauth callback.
.PP
Can optionally set the oauth callback.
.SS "callback_confirmed [callback_confirmed]"
.IX Subsection "callback_confirmed [callback_confirmed]"
Returns the oauth callback confirmed.
.PP
Can optionally set the oauth callback confirmed.
.SS "authorization_url"
.IX Subsection "authorization_url"
Get the url the user needs to visit to authorize as a \s-1URI\s0 object.
.PP
Note: this is the base url \- not the full url with the necessary OAuth params.
.SS "request_token_url"
.IX Subsection "request_token_url"
Get the url to obtain a request token as a \s-1URI\s0 object.
.SS "access_token_url"
.IX Subsection "access_token_url"
Get the url to obtain an access token as a \s-1URI\s0 object.
.SS "request_access_token [param[s]]"
.IX Subsection "request_access_token [param[s]]"
Request the access token and access token secret for this user.
.PP
The user must have authorized this app at the url given by
\&\f(CW\*(C`get_authorization_url\*(C'\fR first.
.PP
Returns the access token and access token secret but also sets
them internally so that after calling this method you can
immediately call a restricted method.
.PP
If you pass in a hash of params then they will added as parameters to the \s-1URL.\s0
.SS "xauth_request_access_token [param[s]]"
.IX Subsection "xauth_request_access_token [param[s]]"
The same as \f(CW\*(C`request_access_token\*(C'\fR but for xAuth.
.PP
For more information on xAuth see
.PP
.Vb 1
\&    http://apiwiki.twitter.com/Twitter\-REST\-API\-Method%3A\-oauth\-access_token\-for\-xAuth
.Ve
.PP
You must pass in the parameters
.PP
.Vb 3
\&    x_auth_username
\&    x_auth_password
\&    x_auth_mode
.Ve
.PP
You must have \s-1HTTPS\s0 enabled for LWP::UserAgent.
.PP
See \f(CW\*(C`examples/twitter_xauth\*(C'\fR for a sample implementation.
.SS "request_request_token [param[s]]"
.IX Subsection "request_request_token [param[s]]"
Request the request token and request token secret for this user.
.PP
This is called automatically by \f(CW\*(C`get_authorization_url\*(C'\fR if necessary.
.PP
If you pass in a hash of params then they will added as parameters to the \s-1URL.\s0
.SS "get_authorization_url [param[s]]"
.IX Subsection "get_authorization_url [param[s]]"
Get the \s-1URL\s0 to authorize a user as a \s-1URI\s0 object.
.PP
If you pass in a hash of params then they will added as parameters to the \s-1URL.\s0
.SS "make_restricted_request <url> <\s-1HTTP\s0 method> [extra[s]]"
.IX Subsection "make_restricted_request <url> <HTTP method> [extra[s]]"
Make a request to \f(CW\*(C`url\*(C'\fR using the given \s-1HTTP\s0 method.
.PP
Any extra parameters can be passed in as a hash.
.SS "make_general_request <url> <\s-1HTTP\s0 method> [extra[s]]"
.IX Subsection "make_general_request <url> <HTTP method> [extra[s]]"
Make a request to \f(CW\*(C`url\*(C'\fR using the given \s-1HTTP\s0 method using 
the general purpose tokens.
.PP
Any extra parameters can be passed in as a hash.
.SS "last_error"
.IX Subsection "last_error"
Get the last error message.
.PP
Only works if \f(CW\*(C`return_undef_on_error\*(C'\fR was passed in to the constructor.
.PP
See the section on \fB\s-1ERROR HANDLING\s0\fR.
.SS "load_tokens <file>"
.IX Subsection "load_tokens <file>"
A convenience method for loading tokens from a config file.
.PP
Returns a hash with the token names suitable for passing to 
\&\f(CW\*(C`new()\*(C'\fR.
.PP
Returns an empty hash if the file doesn't exist.
.SS "save_tokens <file> [token[s]]"
.IX Subsection "save_tokens <file> [token[s]]"
A convenience method to save a hash of tokens out to the given file.
.SH "ERROR HANDLING"
.IX Header "ERROR HANDLING"
Originally this module would die upon encountering an error (inheriting behaviour 
from the original Yahoo! code).
.PP
This is still the default behaviour however if you now pass
.PP
.Vb 1
\&    return_undef_on_error => 1
.Ve
.PP
into the constructor then all methods will return undef on error instead.
.PP
The error message is accessible via the \f(CW\*(C`last_error()\*(C'\fR method.
.SH "GOOGLE'S SCOPE PARAMETER"
.IX Header "GOOGLE'S SCOPE PARAMETER"
Google's OAuth \s-1API\s0 requires the non-standard \f(CW\*(C`scope\*(C'\fR parameter to be set 
in \f(CW\*(C`request_token_url\*(C'\fR, and you also explicitly need to pass an \f(CW\*(C`oauth_callback\*(C'\fR 
to \f(CW\*(C`get_authorization_url()\*(C'\fR method, so that you can direct the user to your site 
if you're authenticating users in Web Application mode. Otherwise Google will let 
user grant acesss as a desktop app mode and doesn't redirect users back.
.PP
Here's an example class that uses Google's Portable Contacts \s-1API\s0 via OAuth:
.PP
.Vb 3
\&    package Net::AppUsingGoogleOAuth;
\&    use strict;
\&    use base qw(Net::OAuth::Simple);
\&
\&    sub new {
\&        my $class  = shift;
\&        my %tokens = @_;
\&        return $class\->SUPER::new(
\&            tokens => \e%tokens, 
\&            urls   => {
\&                request_token_url => "https://www.google.com/accounts/OAuthGetRequestToken?scope=http://www\-opensocial.googleusercontent.com/api/people",
\&                authorization_url => "https://www.google.com/accounts/OAuthAuthorizeToken",
\&                access_token_url  => "https://www.google.com/accounts/OAuthGetAccessToken",
\&            },
\&        );
\&    }
\&
\&    package main;
\&    my $oauth = Net::AppUsingGoogleOAuth\->new(%tokens);
\&
\&    # Web application
\&    $app\->redirect( $oauth\->get_authorization_url( callback => "http://you.example.com/oauth/callback") );
\&
\&    # Desktop application
\&    print "Open the URL and come back once you\*(Aqre authenticated!\en",
\&        $oauth\->get_authorization_url;
.Ve
.PP
See <http://code.google.com/apis/accounts/docs/OAuth.html> and other 
services \s-1API\s0 documentation for the possible list of \fIscope\fR parameter value.
.SH "RANDOMNESS"
.IX Header "RANDOMNESS"
If \f(CW\*(C`Math::Random::MT\*(C'\fR is installed then any nonces generated will use a 
Mersenne Twiser instead of Perl's built in randomness function.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
There are example Twitter and Twitter xAuth 'desktop' apps and a FireEagle OAuth 1.0a web app 
in the examples directory of the distribution.
.SH "BUGS"
.IX Header "BUGS"
Non known
.SH "DEVELOPERS"
.IX Header "DEVELOPERS"
The latest code for this module can be found at
.PP
.Vb 1
\&    https://svn.unixbeard.net/simon/Net\-OAuth\-Simple
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Simon Wistow, \f(CW\*(C`<simon@thegestalt.org \*(C'\fR>
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-net\-oauth\-simple at rt.cpan.org\*(C'\fR, or through
the web interface at <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Net\-OAuth\-Simple>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Net::OAuth::Simple
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Net\-OAuth\-Simple>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/Net\-OAuth\-Simple>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/Net\-OAuth\-Simple>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/Net\-OAuth\-Simple/>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2009 Simon Wistow, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
